<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Pawkey</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Outfit:wght@400;700&display=swap');
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html { touch-action: manipulation; overflow: hidden; }
    body {
      min-height: 100vh;
      min-height: 100dvh;
      height: 100dvh;
      max-height: 100dvh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
      font-family: 'Outfit', sans-serif;
      color: #e8e8e8;
      padding: 12px 20px;
      overflow: hidden;
    }
    .main-content {
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 100%;
      flex: 1 1 auto;
      min-height: 0;
      overflow: hidden;
    }
    .page-header {
      flex-shrink: 0;
      text-align: center;
    }
    h1 {
      font-family: 'Bebas Neue', sans-serif;
      font-size: 2.5rem;
      letter-spacing: 0.15em;
      margin-bottom: 10px;
      color: #ff6b35;
    }
    .subtitle {
      font-size: 0.9rem;
      opacity: 0.8;
      margin-bottom: 8px;
    }
    .control-touch { display: none; }
    .control-desktop { display: inline; }
    @media (pointer: coarse), (max-width: 1024px) {
      .control-touch { display: inline; }
      .control-desktop { display: none; }
    }
    #gameWrapper {
      flex: 1 1 0;
      min-height: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100%;
      overflow: hidden;
    }
    #gameContainer {
      position: relative;
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 20px 60px rgba(0,0,0,0.5);
      max-width: 100%;
      max-height: 100%;
      min-width: 0;
      min-height: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      aspect-ratio: 800 / 500;
    }
    #gameCanvas {
      display: block;
      background: #2d5a4a;
      width: 100%;
      height: 100%;
      object-fit: contain;
    }
    .ui-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      padding: 15px 25px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: linear-gradient(to bottom, rgba(0,0,0,0.7) 0%, transparent 100%);
      pointer-events: none;
    }
    .score-display {
      font-family: 'Bebas Neue', sans-serif;
      font-size: 2rem;
      display: flex;
      gap: 30px;
    }
    .score-display .player-score { color: #ff6b35; }
    .score-display .opponent-score { color: #4a90d9; }
    .period-time {
      font-size: 1.2rem;
      font-weight: 700;
    }
    .instructions {
      flex-shrink: 0;
      margin-top: 8px;
      font-size: 0.85rem;
      opacity: 0.9;
      text-align: center;
    }
    .modal {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.85);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 100;
      padding: 20px;
    }
    .modal h2 {
      font-family: 'Bebas Neue', sans-serif;
      font-size: 2.5rem;
      margin-bottom: 20px;
      color: #ff6b35;
    }
    .modal p {
      margin-bottom: 15px;
      text-align: center;
    }
    .game-over-content {
      position: relative;
      z-index: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    .win-celebration-canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      display: none;
    }
    .win-celebration-canvas.visible {
      display: block;
    }
    .modal button {
      padding: 12px 40px;
      font-size: 1.1rem;
      font-family: 'Outfit', sans-serif;
      font-weight: 700;
      background: #ff6b35;
      border: none;
      border-radius: 8px;
      color: white;
      cursor: pointer;
    }
    .modal button:hover {
      background: #ff8555;
      transform: scale(1.02);
    }
    .game-row {
      flex-shrink: 0;
      display: flex;
      justify-content: center;
      margin-bottom: 6px;
      min-height: 36px;
    }
    #pauseBtn {
      padding: 8px 24px;
      font-size: 1rem;
      font-family: 'Outfit', sans-serif;
      font-weight: 700;
      background: #ff6b35;
      border: none;
      border-radius: 8px;
      color: white;
      cursor: pointer;
    }
    #pauseBtn:hover {
      background: #ff8555;
    }
    #pauseBtn.hidden { display: none; }

    .hidden { display: none !important; }

    @media (max-width: 600px) {
      body { padding: 10px 8px; }
      h1 { font-size: 1.6rem; letter-spacing: 0.08em; }
      .subtitle { font-size: 0.75rem; margin-bottom: 8px; }
      .instructions { font-size: 0.7rem; margin-top: 4px; }
      .ui-overlay { padding: 10px 14px; }
      .score-display { font-size: 1.4rem; gap: 18px; }
      .period-time { font-size: 0.8rem; }
    }
    @media (max-width: 400px) {
      .ui-overlay { padding: 8px 10px; }
      .score-display { font-size: 1.2rem; gap: 14px; }
      .period-time { font-size: 0.7rem; }
    }
    @media (orientation: landscape) and (max-height: 500px) {
      body { padding: 4px 12px; }
      .page-header h1 { font-size: 1.2rem; margin-bottom: 2px; }
      .subtitle { font-size: 0.65rem; margin-bottom: 2px; }
      .game-row { margin-bottom: 2px; min-height: 28px; }
      #pauseBtn { padding: 4px 16px; font-size: 0.85rem; }
      .instructions { font-size: 0.6rem; margin-top: 2px; }
      .ui-overlay { padding: 8px 12px; }
      .score-display { font-size: 1.2rem; gap: 14px; }
      .period-time { font-size: 0.7rem; }
    }
    @media (orientation: landscape) and (max-height: 400px) {
      body { padding: 2px 8px; }
      .page-header h1 { font-size: 1rem; margin-bottom: 0; }
      .subtitle { font-size: 0.6rem; margin-bottom: 0; }
      .game-row { margin-bottom: 0; min-height: 24px; }
      #pauseBtn { padding: 2px 12px; font-size: 0.75rem; }
      .instructions { font-size: 0.55rem; margin-top: 0; }
      .ui-overlay { padding: 6px 10px; }
      .score-display { font-size: 1rem; gap: 12px; }
      .period-time { font-size: 0.6rem; }
    }

    #joystickContainer {
      display: none;
      position: fixed;
      left: 0;
      bottom: 0;
      z-index: 50;
      padding: 20px;
      padding-left: max(20px, env(safe-area-inset-left));
      padding-bottom: max(20px, env(safe-area-inset-bottom));
      touch-action: none;
      user-select: none;
    }
    #joystickContainer.visible {
      display: block;
    }
    #joystickBase {
      width: min(120px, 28vw);
      height: min(120px, 28vw);
      border-radius: 50%;
      background: rgba(255,107,53,0.35);
      border: 3px solid rgba(255,107,53,0.8);
      position: relative;
      touch-action: none;
    }
    #joystickStick {
      width: min(48px, 11vw);
      height: min(48px, 11vw);
      border-radius: 50%;
      background: rgba(255,107,53,0.9);
      border: 2px solid rgba(255,255,255,0.6);
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      pointer-events: none;
      transition: transform 0.05s ease-out;
    }
    #joystickStick.active {
      transition: none;
    }

    #rotateOverlay {
      display: none;
      position: fixed;
      inset: 0;
      z-index: 200;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 24px;
      text-align: center;
    }
    #rotateOverlay.visible {
      display: flex;
    }
    #rotateOverlay .rotate-icon {
      font-size: 4rem;
      margin-bottom: 20px;
      animation: rotate-hint 2s ease-in-out infinite;
    }
    @keyframes rotate-hint {
      0%, 100% { transform: rotate(-90deg); }
      50% { transform: rotate(0deg); }
    }
    #rotateOverlay h2 {
      font-family: 'Bebas Neue', sans-serif;
      font-size: 1.8rem;
      color: #ff6b35;
      margin-bottom: 12px;
    }
    #rotateOverlay p {
      font-size: 1rem;
      opacity: 0.9;
    }
    @media (min-width: 901px) {
      #rotateOverlay { display: none !important; }
    }
    @media (orientation: landscape) {
      #rotateOverlay { display: none !important; }
      body .main-content { display: flex !important; }
    }
    @media (orientation: portrait) and (max-width: 900px) {
      #rotateOverlay { display: flex !important; }
      body .main-content { display: none !important; }
    }
  </style>
</head>
<body>
  <div id="rotateOverlay" class="visible" aria-live="polite">
    <span class="rotate-icon" aria-hidden="true">üì±</span>
    <h2>Rotate to play</h2>
    <p>Please turn your device sideways<br>to play Pawkey.</p>
  </div>

  <div class="main-content">
  <header class="page-header">
    <h1>üê± PAWKEY üê±</h1>
    <p class="subtitle">Overhead ice rink ‚Ä¢ <span class="control-desktop">Arrow keys</span><span class="control-touch">Joystick</span> ‚Ä¢ Bump the puck to shoot</p>
  </header>
  <div class="game-row">
    <button id="pauseBtn" class="hidden">Pawws</button>
  </div>
  <div id="gameWrapper">
  <div id="gameContainer">
    <canvas id="gameCanvas" width="800" height="500"></canvas>
    <div class="ui-overlay">
      <div class="score-display">
        <span id="playerScore" class="player-score">0</span>
        <span>-</span>
        <span id="opponentScore" class="opponent-score">0</span>
      </div>
      <div class="period-time">
        <span id="periodLabel">Period 1</span> ‚Ä¢ <span id="timerDisplay">1:30</span>
      </div>
    </div>
  </div>
  </div>
  <p class="instructions">Arrow keys: Move your cat ‚Ä¢ Bump into the puck to move it ‚Ä¢ 3 periods √ó 1:30 ‚Ä¢ Overtime if tied</p>
  </div>

  <div id="startModal" class="modal">
    <h2>Pawkey</h2>
    <p>You (orange) vs the other cat (blue)<br>Bump the puck with the mouse on it into the goal!</p>
    <button id="startBtn">Start Game</button>
  </div>

  <div id="intermissionModal" class="modal hidden">
    <h2 id="intermissionTitle">Intermission</h2>
    <p id="intermissionText">Get ready for the next period!</p>
    <button id="intermissionBtn">Continue</button>
  </div>

  <div id="gameOverModal" class="modal hidden">
    <canvas id="winCelebrationCanvas" class="win-celebration-canvas" aria-hidden="true"></canvas>
    <div class="game-over-content">
      <h2 id="gameOverTitle">Game Over</h2>
      <p id="gameOverText"></p>
      <button id="playAgainBtn">Play Again</button>
    </div>
  </div>

  <div id="joystickContainer" aria-hidden="true">
    <div id="joystickBase">
      <div id="joystickStick"></div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    const RINK_WIDTH = 800;
    const RINK_HEIGHT = 500;
    const GOAL_WIDTH = 120;
    const GOAL_DEPTH = 20;
    const PUCK_RADIUS = 12;
    const CAT_RADIUS = 22;
    const ICE_FRICTION = 0.9992;
    const MAX_PUCK_SPEED = 180;
    const MAX_CAT_SPEED = 230;
    const PERIOD_DURATION = 90;
    const OVERTIME_DURATION = 120;

    const GOAL_TOP = RINK_HEIGHT / 2 - GOAL_WIDTH / 2;
    const GOAL_BOTTOM = RINK_HEIGHT / 2 + GOAL_WIDTH / 2;

    let keys = {};
    let gameState = 'start';
    let puck, playerCat, opponentCat;
    let goalCelebrationStartTime = 0;
    let goalCelebrationColor = '#ff6b35';
    let goalCelebrationPlayerScored = false;
    let fireworks = [];
    let playerScore = 0, opponentScore = 0;
    let currentPeriod = 1;
    let periodTimeLeft = PERIOD_DURATION;
    let isOvertime = false;
    let lastTime = 0;
    let animationId;
    let winFireworks = [];
    let winConfetti = [];
    let winCelebrationStartTime = 0;
    let winCelebrationId = null;
    let lastWinFrameTime = 0;

    class Vector {
      constructor(x = 0, y = 0) {
        this.x = x;
        this.y = y;
      }
      add(v) { this.x += v.x; this.y += v.y; return this; }
      sub(v) { this.x -= v.x; this.y -= v.y; return this; }
      mul(s) { this.x *= s; this.y *= s; return this; }
      length() { return Math.sqrt(this.x * this.x + this.y * this.y); }
      normalize() {
        const len = this.length();
        if (len > 0) { this.x /= len; this.y /= len; }
        return this;
      }
      set(x, y) { this.x = x; this.y = y; return this; }
      copy() { return new Vector(this.x, this.y); }
    }

    class Puck {
      constructor() {
        this.pos = new Vector(RINK_WIDTH / 2, RINK_HEIGHT / 2);
        this.vel = new Vector(0, 0);
        this.radius = PUCK_RADIUS;
      }
      update(dt) {
        this.vel.mul(Math.pow(ICE_FRICTION, dt / 16));
        this.pos.add(new Vector(this.vel.x * dt / 1000, this.vel.y * dt / 1000));
        const speed = this.vel.length();
        if (speed > MAX_PUCK_SPEED) this.vel.mul(MAX_PUCK_SPEED / speed);
        this.checkBounds();
      }
      checkBounds() {
        const wallBounce = 0.97;
        const cornerMargin = this.radius * 2.5;
        if (this.pos.y - this.radius < 0) { this.pos.y = this.radius; this.vel.y = Math.abs(this.vel.y) * wallBounce; }
        if (this.pos.y + this.radius > RINK_HEIGHT) { this.pos.y = RINK_HEIGHT - this.radius; this.vel.y = -Math.abs(this.vel.y) * wallBounce; }
        const inGoalY = this.pos.y > GOAL_TOP && this.pos.y < GOAL_BOTTOM;
        if (this.pos.x - this.radius < 0) {
          if (!inGoalY) { this.pos.x = this.radius; this.vel.x = Math.abs(this.vel.x) * wallBounce; }
        } else if (this.pos.x + this.radius > RINK_WIDTH) {
          if (!inGoalY) { this.pos.x = RINK_WIDTH - this.radius; this.vel.x = -Math.abs(this.vel.x) * wallBounce; }
        }
        const speed = Math.sqrt(this.vel.x * this.vel.x + this.vel.y * this.vel.y);
        const cornerNudge = 6;
        const inCorner = (this.pos.x < cornerMargin && this.pos.y < cornerMargin) ||
          (this.pos.x < cornerMargin && this.pos.y > RINK_HEIGHT - cornerMargin) ||
          (this.pos.x > RINK_WIDTH - cornerMargin && this.pos.y < cornerMargin) ||
          (this.pos.x > RINK_WIDTH - cornerMargin && this.pos.y > RINK_HEIGHT - cornerMargin);
        if (inCorner && speed < 15) {
          if (this.pos.x < cornerMargin && this.pos.y < cornerMargin) {
            this.vel.x += cornerNudge;
            this.vel.y += cornerNudge;
          } else if (this.pos.x < cornerMargin && this.pos.y > RINK_HEIGHT - cornerMargin) {
            this.vel.x += cornerNudge;
            this.vel.y -= cornerNudge;
          } else if (this.pos.x > RINK_WIDTH - cornerMargin && this.pos.y < cornerMargin) {
            this.vel.x -= cornerNudge;
            this.vel.y += cornerNudge;
          } else if (this.pos.x > RINK_WIDTH - cornerMargin && this.pos.y > RINK_HEIGHT - cornerMargin) {
            this.vel.x -= cornerNudge;
            this.vel.y -= cornerNudge;
          }
        }
      }
      reset(toLeft = null) {
        this.pos.set(RINK_WIDTH / 2, RINK_HEIGHT / 2);
        this.vel.set(0, 0);
      }
      draw() {
        ctx.save();
        ctx.translate(this.pos.x, this.pos.y);
        ctx.fillStyle = '#1a1a1a';
        ctx.beginPath();
        ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.font = '18px serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('üê≠', 0, 0);
        ctx.restore();
      }
    }

    class Cat {
      constructor(x, color, isPlayer) {
        this.pos = new Vector(x, RINK_HEIGHT / 2);
        this.vel = new Vector(0, 0);
        this.radius = CAT_RADIUS;
        this.color = color;
        this.isPlayer = isPlayer;
      }
      update(dt, puck) {
        if (this.isPlayer) {
          const accel = 15360;
          if (keys['ArrowUp']) this.vel.y -= accel * dt / 1000;
          if (keys['ArrowDown']) this.vel.y += accel * dt / 1000;
          if (keys['ArrowLeft']) this.vel.x -= accel * dt / 1000;
          if (keys['ArrowRight']) this.vel.x += accel * dt / 1000;
        } else {
          this.aiMove(puck, dt);
        }
        this.vel.mul(Math.pow(0.97, dt / 16));
        const speed = this.vel.length();
        const maxSpeed = this.isPlayer ? MAX_CAT_SPEED : MAX_CAT_SPEED * 0.75;
        if (speed > maxSpeed) this.vel.mul(maxSpeed / speed);
        this.pos.add(new Vector(this.vel.x * dt / 1000, this.vel.y * dt / 1000));
        this.checkBounds();
      }
      aiMove(puck, dt) {
        const cornerMargin = 40;
        const inCorner = (puck.pos.x < cornerMargin && puck.pos.y < cornerMargin) ||
          (puck.pos.x < cornerMargin && puck.pos.y > RINK_HEIGHT - cornerMargin) ||
          (puck.pos.x > RINK_WIDTH - cornerMargin && puck.pos.y < cornerMargin) ||
          (puck.pos.x > RINK_WIDTH - cornerMargin && puck.pos.y > RINK_HEIGHT - cornerMargin);
        let targetX = puck.pos.x;
        let targetY = puck.pos.y;
        if (inCorner) {
          const cx = RINK_WIDTH / 2;
          const cy = RINK_HEIGHT / 2;
          const ax = cx - puck.pos.x;
          const ay = cy - puck.pos.y;
          const len = Math.sqrt(ax * ax + ay * ay) || 1;
          targetX = puck.pos.x + (ax / len) * 175;
          targetY = puck.pos.y + (ay / len) * 175;
        }
        let dx = targetX - this.pos.x;
        let dy = targetY - this.pos.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < 5) return;
        const push = 9830;
        const t = dt / 1000;
        this.vel.x += (dx / dist) * push * t;
        this.vel.y += (dy / dist) * push * t;
      }
      checkBounds() {
        const margin = 8;
        if (this.pos.x - this.radius < margin) { this.pos.x = margin + this.radius; this.vel.x = 0; }
        if (this.pos.x + this.radius > RINK_WIDTH - margin) { this.pos.x = RINK_WIDTH - margin - this.radius; this.vel.x = 0; }
        if (this.pos.y - this.radius < margin) { this.pos.y = margin + this.radius; this.vel.y = 0; }
        if (this.pos.y + this.radius > RINK_HEIGHT - margin) { this.pos.y = RINK_HEIGHT - margin - this.radius; this.vel.y = 0; }
      }
      reset(x) {
        this.pos.set(x, RINK_HEIGHT / 2);
        this.vel.set(0, 0);
      }
      draw() {
        ctx.save();
        ctx.translate(this.pos.x, this.pos.y);
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#222';
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.fillStyle = '#fff';
        ctx.font = `${this.radius * 1.4}px serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('üê±', 0, 0);
        ctx.restore();
      }
    }

    function circleCircleCollision(aPos, aVel, aRad, bPos, bVel, bRad, aMass, bMass) {
      const dx = bPos.x - aPos.x;
      const dy = bPos.y - aPos.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const minDist = aRad + bRad;
      if (dist >= minDist) return false;
      const nx = dx / dist;
      const ny = dy / dist;
      const relVx = aVel.x - bVel.x;
      const relVy = aVel.y - bVel.y;
      const relVn = relVx * nx + relVy * ny;
      if (relVn <= 0) return false;
      const e = 0.95;
      const j = (1 + e) * relVn / (1 / aMass + 1 / bMass);
      return { nx, ny, j };
    }

    function resolveCollision(cat, puck) {
      const col = circleCircleCollision(
        cat.pos, cat.vel, cat.radius,
        puck.pos, puck.vel, puck.radius,
        1.2, 0.4
      );
      if (!col) return;
      puck.vel.x += col.j * col.nx / 0.4;
      puck.vel.y += col.j * col.ny / 0.4;
      cat.vel.x -= col.j * col.nx / 1.2;
      cat.vel.y -= col.j * col.ny / 1.2;
      const catSpeed = Math.sqrt(cat.vel.x * cat.vel.x + cat.vel.y * cat.vel.y);
      if (catSpeed > 2) {
        const transfer = 0.4;
        puck.vel.x += cat.vel.x * transfer;
        puck.vel.y += cat.vel.y * transfer;
      }
      const overlap = (cat.radius + puck.radius) - Math.sqrt(
        Math.pow(puck.pos.x - cat.pos.x, 2) + Math.pow(puck.pos.y - cat.pos.y, 2)
      );
      if (overlap > 0) {
        const sx = (cat.pos.x - puck.pos.x) / (cat.radius + puck.radius);
        const sy = (cat.pos.y - puck.pos.y) / (cat.radius + puck.radius);
        puck.pos.x -= sx * overlap;
        puck.pos.y -= sy * overlap;
      }
    }

    function startGoalCelebration(playerScored) {
      goalCelebrationStartTime = performance.now();
      goalCelebrationColor = playerScored ? '#ff6b35' : '#4a90d9';
      goalCelebrationPlayerScored = playerScored;
      gameState = 'goalCelebration';
      fireworks = [];
      for (let i = 0; i < 8; i++) {
        setTimeout(() => spawnFirework(), i * 380);
      }
    }

    function spawnFirework() {
      const x = 150 + Math.random() * 500;
      const y = 150 + Math.random() * 200;
      const hue = goalCelebrationColor === '#ff6b35' ? 20 : 210;
      const particleCount = 45 + Math.floor(Math.random() * 20);
      for (let i = 0; i < particleCount; i++) {
        const angle = (Math.PI * 2 * i / particleCount) + Math.random() * 0.5;
        const speed = 3 + Math.random() * 5;
        fireworks.push({
          x, y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed - 2,
          life: 1,
          hue: hue + (Math.random() - 0.5) * 30,
          size: 2 + Math.random() * 2
        });
      }
    }

    function updateFireworks(dt) {
      for (let i = fireworks.length - 1; i >= 0; i--) {
        const p = fireworks[i];
        p.x += p.vx * dt / 20;
        p.y += p.vy * dt / 20;
        p.vy += 0.15 * dt / 20;
        p.life -= dt / 1200;
        if (p.life <= 0) fireworks.splice(i, 1);
      }
    }

    function drawGoalCelebration(dt) {
      const elapsed = performance.now() - goalCelebrationStartTime;
      ctx.fillStyle = 'rgba(0,0,0,0.35)';
      ctx.fillRect(0, 0, RINK_WIDTH, RINK_HEIGHT);
      updateFireworks(dt);
      fireworks.forEach(p => {
        ctx.save();
        ctx.globalAlpha = p.life;
        ctx.fillStyle = `hsl(${p.hue}, 85%, 55%)`;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      });
      ctx.save();
      const meowAlpha = Math.min(1, elapsed / 300) * Math.max(0, 1 - (elapsed - 2500) / 800);
      const meowScale = Math.min(1, elapsed / 200) * 0.7 + 0.3;
      ctx.globalAlpha = meowAlpha;
      ctx.translate(RINK_WIDTH / 2, RINK_HEIGHT / 2);
      ctx.scale(meowScale, meowScale);
      ctx.translate(-RINK_WIDTH / 2, -RINK_HEIGHT / 2);
      ctx.font = 'bold 96px "Bebas Neue", impact, sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = goalCelebrationColor;
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 4;
      ctx.strokeText('MEOW!', RINK_WIDTH / 2, RINK_HEIGHT / 2);
      ctx.fillText('MEOW!', RINK_WIDTH / 2, RINK_HEIGHT / 2);
      ctx.restore();
    }

    function initWinCelebration() {
      const w = document.documentElement.clientWidth;
      const h = document.documentElement.clientHeight;
      const winCanvas = document.getElementById('winCelebrationCanvas');
      winCanvas.width = w;
      winCanvas.height = h;
      winFireworks = [];
      winConfetti = [];
      winCelebrationStartTime = performance.now();
      const colors = ['#ff6b35', '#4a90d9', '#ffd700', '#ff69b4', '#7b68ee', '#00ced1', '#ff4500'];
      for (let i = 0; i < 6; i++) {
        setTimeout(() => {
          const x = w * (0.2 + Math.random() * 0.6);
          const y = h * (0.2 + Math.random() * 0.4);
          const hue = 20 + Math.random() * 40;
          for (let j = 0; j < 50; j++) {
            const angle = (Math.PI * 2 * j / 50) + Math.random();
            const speed = 2 + Math.random() * 4;
            winFireworks.push({
              x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed - 1,
              life: 1, hue: hue + (Math.random() - 0.5) * 20, size: 1.5 + Math.random() * 2
            });
          }
        }, i * 400);
      }
      for (let i = 0; i < 120; i++) {
        winConfetti.push({
          x: w / 2, y: h / 2,
          vx: (Math.random() - 0.5) * 14, vy: (Math.random() - 0.6) * 12,
          color: colors[Math.floor(Math.random() * colors.length)],
          size: 6 + Math.random() * 10, rotation: Math.random() * 360, rotSpeed: (Math.random() - 0.5) * 20,
          life: 1
        });
      }
    }

    function updateWinCelebration(dt) {
      const w = document.getElementById('winCelebrationCanvas').width;
      const h = document.getElementById('winCelebrationCanvas').height;
      const g = 0.2;
      winFireworks.forEach(p => {
        p.x += p.vx * dt / 16;
        p.y += p.vy * dt / 16;
        p.vy += 0.12 * dt / 16;
        p.life -= dt / 2000;
      });
      winFireworks = winFireworks.filter(p => p.life > 0);
      winConfetti.forEach(c => {
        c.x += c.vx * dt / 16;
        c.y += c.vy * dt / 16;
        c.vy += g * dt / 16;
        c.rotation += c.rotSpeed * dt / 100;
        c.life -= dt / 4000;
      });
      winConfetti = winConfetti.filter(c => c.life > 0);
    }

    function drawWinCelebration() {
      const winCanvas = document.getElementById('winCelebrationCanvas');
      if (!winCanvas.classList.contains('visible')) return;
      const w = winCanvas.width;
      const h = winCanvas.height;
      const wctx = winCanvas.getContext('2d');
      wctx.clearRect(0, 0, w, h);
      winFireworks.forEach(p => {
        wctx.save();
        wctx.globalAlpha = p.life;
        wctx.fillStyle = `hsl(${p.hue}, 85%, 55%)`;
        wctx.beginPath();
        wctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        wctx.fill();
        wctx.restore();
      });
      winConfetti.forEach(c => {
        wctx.save();
        wctx.globalAlpha = c.life;
        wctx.translate(c.x, c.y);
        wctx.rotate(c.rotation * Math.PI / 180);
        wctx.fillStyle = c.color;
        wctx.fillRect(-c.size / 2, -c.size / 4, c.size, c.size / 2);
        wctx.restore();
      });
    }

    function runWinCelebrationLoop(timestamp) {
      const dt = lastWinFrameTime ? Math.min(timestamp - lastWinFrameTime, 50) : 16;
      lastWinFrameTime = timestamp;
      updateWinCelebration(dt);
      drawWinCelebration();
      if (document.getElementById('gameOverModal').classList.contains('hidden')) {
        cancelAnimationFrame(winCelebrationId);
        winCelebrationId = null;
        return;
      }
      winCelebrationId = requestAnimationFrame(runWinCelebrationLoop);
    }

    function checkGoals() {
      if (puck.pos.x - puck.radius < 0 && puck.pos.y > GOAL_TOP && puck.pos.y < GOAL_BOTTOM) {
        opponentScore++;
        if (isOvertime) {
          gameState = 'gameover';
          document.getElementById('gameOverModal').classList.remove('hidden');
          document.getElementById('gameOverTitle').textContent = 'You Lose!';
          document.getElementById('gameOverText').textContent = `OT Final: ${playerScore} - ${opponentScore}`;
          document.getElementById('winCelebrationCanvas').classList.remove('visible');
        } else {
          startGoalCelebration(false);
        }
        return true;
      }
      if (puck.pos.x + puck.radius > RINK_WIDTH && puck.pos.y > GOAL_TOP && puck.pos.y < GOAL_BOTTOM) {
        playerScore++;
        if (isOvertime) {
          gameState = 'gameover';
          const modal = document.getElementById('gameOverModal');
          const titleEl = document.getElementById('gameOverTitle');
          const textEl = document.getElementById('gameOverText');
          const winCanvas = document.getElementById('winCelebrationCanvas');
          modal.classList.remove('hidden');
          titleEl.textContent = 'Puuurrrfect!';
          textEl.textContent = `OT Final: ${playerScore} - ${opponentScore}`;
          winCanvas.classList.add('visible');
          initWinCelebration();
          lastWinFrameTime = 0;
          winCelebrationId = requestAnimationFrame(runWinCelebrationLoop);
        } else {
          startGoalCelebration(true);
        }
        return true;
      }
      return false;
    }

    function resetAfterGoal(scoreLeft) {
      puck.reset();
      playerCat.reset(80);
      opponentCat.reset(RINK_WIDTH - 80);
    }

    function drawRink() {
      ctx.fillStyle = '#2d5a4a';
      ctx.fillRect(0, 0, RINK_WIDTH, RINK_HEIGHT);
      ctx.strokeStyle = '#4a7c6b';
      ctx.lineWidth = 4;
      ctx.strokeRect(2, 2, RINK_WIDTH - 4, RINK_HEIGHT - 4);
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 2;
      ctx.strokeRect(RINK_WIDTH / 2 - 1, 0, 2, RINK_HEIGHT);
      ctx.beginPath();
      ctx.arc(RINK_WIDTH / 2, RINK_HEIGHT / 2, 60, 0, Math.PI * 2);
      ctx.stroke();
      ctx.fillStyle = 'rgba(0,0,0,0.5)';
      ctx.fillRect(0, GOAL_TOP, GOAL_DEPTH, GOAL_WIDTH);
      ctx.fillRect(RINK_WIDTH - GOAL_DEPTH, GOAL_TOP, GOAL_DEPTH, GOAL_WIDTH);
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 3;
      ctx.strokeRect(0, GOAL_TOP, GOAL_DEPTH, GOAL_WIDTH);
      ctx.strokeRect(RINK_WIDTH - GOAL_DEPTH, GOAL_TOP, GOAL_DEPTH, GOAL_WIDTH);
    }

    function formatTime(seconds) {
      const m = Math.floor(seconds / 60);
      const s = Math.floor(seconds % 60);
      return `${m}:${s.toString().padStart(2, '0')}`;
    }

    function updateUI() {
      document.getElementById('playerScore').textContent = playerScore;
      document.getElementById('opponentScore').textContent = opponentScore;
      document.getElementById('timerDisplay').textContent = formatTime(periodTimeLeft);
      document.getElementById('periodLabel').textContent = isOvertime ? 'OT' : `Period ${currentPeriod}`;
    }

    function nextPeriodOrEnd() {
      if (isOvertime) {
        gameState = 'gameover';
        document.getElementById('gameOverModal').classList.remove('hidden');
        document.getElementById('gameOverTitle').textContent = 'Tie Game!';
        document.getElementById('gameOverText').textContent = `Final: ${playerScore} - ${opponentScore}`;
        document.getElementById('winCelebrationCanvas').classList.remove('visible');
      } else if (currentPeriod < 3) {
        gameState = 'intermission';
        currentPeriod++;
        periodTimeLeft = PERIOD_DURATION;
        document.getElementById('intermissionModal').classList.remove('hidden');
        document.getElementById('intermissionTitle').textContent = 'Intermission';
        document.getElementById('intermissionText').textContent = `Period ${currentPeriod - 1} complete. Score: ${playerScore} - ${opponentScore}`;
      } else {
        if (playerScore === opponentScore) {
          isOvertime = true;
          periodTimeLeft = OVERTIME_DURATION;
          gameState = 'intermission';
          document.getElementById('intermissionModal').classList.remove('hidden');
          document.getElementById('intermissionTitle').textContent = 'Overtime!';
          document.getElementById('intermissionText').textContent = 'Sudden death - first goal wins! 2 minutes. Tie if no goal.';
        } else {
          gameState = 'gameover';
          const modal = document.getElementById('gameOverModal');
          const titleEl = document.getElementById('gameOverTitle');
          const textEl = document.getElementById('gameOverText');
          const winCanvas = document.getElementById('winCelebrationCanvas');
          modal.classList.remove('hidden');
          const won = playerScore > opponentScore;
          titleEl.textContent = won ? 'Puuurrrfect!' : 'You Lose!';
          textEl.textContent = `Final: ${playerScore} - ${opponentScore}`;
          if (won) {
            winCanvas.classList.add('visible');
            initWinCelebration();
            lastWinFrameTime = 0;
            winCelebrationId = requestAnimationFrame(runWinCelebrationLoop);
          } else {
            winCanvas.classList.remove('visible');
          }
        }
      }
    }

    function gameLoop(timestamp) {
      const dt = Math.min(timestamp - lastTime, 50);
      lastTime = timestamp;

      if (gameState === 'playing') {
        periodTimeLeft -= dt / 1000;
        if (periodTimeLeft <= 0) {
          periodTimeLeft = 0;
          nextPeriodOrEnd();
        }

        playerCat.update(dt, puck);
        opponentCat.update(dt, puck);
        puck.update(dt);
        resolveCollision(playerCat, puck);
        resolveCollision(opponentCat, puck);
        checkGoals();
      } else if (gameState === 'paused') {
        // no updates; draw paused overlay below
      } else if (gameState === 'goalCelebration') {
        const elapsed = performance.now() - goalCelebrationStartTime;
        if (elapsed >= 4000) {
          resetAfterGoal(!goalCelebrationPlayerScored);
          gameState = 'playing';
        }
      }

      drawRink();
      if (puck && playerCat && opponentCat) {
        puck.draw();
        playerCat.draw();
        opponentCat.draw();
      }
      if (gameState === 'goalCelebration') {
        drawGoalCelebration(dt);
      }
      if (gameState === 'paused') {
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.fillRect(0, 0, RINK_WIDTH, RINK_HEIGHT);
        ctx.font = 'bold 48px "Bebas Neue", sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = '#fff';
        ctx.fillText('Paused üêæ', RINK_WIDTH / 2, RINK_HEIGHT / 2);
      }
      updateUI();

      animationId = requestAnimationFrame(gameLoop);
    }

    function initGame() {
      puck = new Puck();
      playerCat = new Cat(80, '#ff6b35', true);
      opponentCat = new Cat(RINK_WIDTH - 80, '#4a90d9', false);
      playerScore = 0;
      opponentScore = 0;
      currentPeriod = 1;
      periodTimeLeft = PERIOD_DURATION;
      isOvertime = false;
      gameState = 'playing';
    }

    document.getElementById('startBtn').addEventListener('click', () => {
      document.getElementById('startModal').classList.add('hidden');
      initGame();
      const pauseBtn = document.getElementById('pauseBtn');
      pauseBtn.classList.remove('hidden');
      pauseBtn.textContent = 'Pawws';
    });

    document.getElementById('intermissionBtn').addEventListener('click', () => {
      document.getElementById('intermissionModal').classList.add('hidden');
      puck.reset();
      playerCat.reset(80);
      opponentCat.reset(RINK_WIDTH - 80);
      gameState = 'playing';
    });

    document.getElementById('playAgainBtn').addEventListener('click', () => {
      document.getElementById('gameOverModal').classList.add('hidden');
      document.getElementById('winCelebrationCanvas').classList.remove('visible');
      if (winCelebrationId !== null) {
        cancelAnimationFrame(winCelebrationId);
        winCelebrationId = null;
      }
      document.getElementById('startModal').classList.remove('hidden');
      document.getElementById('pauseBtn').classList.add('hidden');
    });

    document.getElementById('pauseBtn').addEventListener('click', () => {
      if (gameState === 'playing') {
        gameState = 'paused';
        document.getElementById('pauseBtn').textContent = 'Resume';
      } else if (gameState === 'paused') {
        gameState = 'playing';
        document.getElementById('pauseBtn').textContent = 'Pawws';
      }
    });

    document.addEventListener('keydown', e => {
      if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)) e.preventDefault();
      keys[e.key] = true;
    });
    document.addEventListener('keyup', e => { keys[e.key] = false; });

    (function initJoystick() {
      const hasTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
      if (!hasTouch) return;
      const container = document.getElementById('joystickContainer');
      const base = document.getElementById('joystickBase');
      const stick = document.getElementById('joystickStick');
      container.classList.add('visible');

      const deadzone = 0.2;
      let baseCenter = { x: 0, y: 0 };
      let activeTouchId = null;

      function setKeysFromStick(dx, dy) {
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < 1) {
          keys['ArrowUp'] = false;
          keys['ArrowDown'] = false;
          keys['ArrowLeft'] = false;
          keys['ArrowRight'] = false;
          return;
        }
        const nx = dx / dist;
        const ny = dy / dist;
        const thresh = deadzone;
        keys['ArrowUp'] = ny < -thresh;
        keys['ArrowDown'] = ny > thresh;
        keys['ArrowLeft'] = nx < -thresh;
        keys['ArrowRight'] = nx > thresh;
      }

      function onTouchStart(e) {
        if (activeTouchId !== null) return;
        const touch = e.changedTouches[0];
        activeTouchId = touch.identifier;
        const rect = base.getBoundingClientRect();
        baseCenter.x = rect.left + rect.width / 2;
        baseCenter.y = rect.top + rect.height / 2;
        baseCenter.maxDist = Math.min(rect.width, rect.height) * 0.3;
        stick.classList.add('active');
        e.preventDefault();
      }

      function onTouchMove(e) {
        const touch = Array.from(e.changedTouches).find(t => t.identifier === activeTouchId);
        if (!touch) return;
        const dx = touch.clientX - baseCenter.x;
        const dy = touch.clientY - baseCenter.y;
        const maxDist = baseCenter.maxDist || 36;
        const dist = Math.min(maxDist, Math.sqrt(dx * dx + dy * dy));
        const angle = Math.atan2(dy, dx);
        const clampX = Math.cos(angle) * dist;
        const clampY = Math.sin(angle) * dist;
        stick.style.transform = `translate(calc(-50% + ${clampX}px), calc(-50% + ${clampY}px))`;
        setKeysFromStick(clampX, clampY);
        e.preventDefault();
      }

      function onTouchEnd(e) {
        const touch = Array.from(e.changedTouches).find(t => t.identifier === activeTouchId);
        if (!touch) return;
        activeTouchId = null;
        stick.style.transform = 'translate(-50%, -50%)';
        stick.classList.remove('active');
        keys['ArrowUp'] = false;
        keys['ArrowDown'] = false;
        keys['ArrowLeft'] = false;
        keys['ArrowRight'] = false;
      }

      base.addEventListener('touchstart', onTouchStart, { passive: false });
      document.addEventListener('touchmove', onTouchMove, { passive: false });
      document.addEventListener('touchend', onTouchEnd, { passive: true });
      document.addEventListener('touchcancel', onTouchEnd, { passive: true });
    })();

    lastTime = performance.now();
    animationId = requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
